# FormDoc ðŸ“

**FormDoc** is a powerful Kotlin Multiplatform library designed to simplify form validation. By leveraging **KSP (Kotlin Symbol Processing)** and **Annotations**, it automates the generation of validation metadata, allowing you to focus on building great UIs.

Designed with **Compose Multiplatform** in mind, FormDoc provides a seamless way to manage form states and validation errors across Android, iOS, Desktop, and Web.

---

## âœ¨ Features

- ðŸš€ **Annotation-based Validation:** Define validation rules directly on your data models.
- ðŸ› ï¸ **KSP Powered:** Compile-time metadata generation means no reflection overhead.
- ðŸŽ¨ **Compose Ready:** Built-in support for `mutableStateOf` based form tracking.
- ðŸŒ **Multiplatform:** Consistent validation logic across all KMP targets.
- ðŸ§© **Extensible:** Easily create custom validators for complex business logic.

---

## ðŸ› ï¸ Usage

### 1. Annotate your Data Model

Mark your class with `@Validatable` and use built-in constraints like `@NotBlank`, `@Email`, or `@Min`.

```kotlin
@Validatable
data class UserProfile(
    @NotBlank(message = "Username is required")
    val username: String = "",
    
    @Email(message = "Invalid email format")
    val email: String = "",
    
    @Min(value = 18, message = "Must be at least 18 years old")
    val age: Int = 0
)
```

### 2. Compose Integration

Use `rememberFormState` to initialize your form. FormDoc uses the KSP-generated `UserProfileMetadata` to apply the rules.

```kotlin
@Composable
fun RegistrationForm() {
    val formState = rememberFormState(
        initial = UserProfile(),
        metadata = UserProfileMetadata() // Generated by KSP
    )

    FormContent(formState) {
        Column {
            val nameState = state.getState(UserProfile::username)
            TextField(
                value = nameState.value,
                onValueChange = { nameState.value = it },
                label = { Text("Username") },
                isError = nameState.error != null,
                supportingText = { nameState.error?.let { Text(it) } }
            )
            
            Button(onClick = {
                state.submit(
                    onValid = { data -> println("Success: $data") },
                    onInvalid = { errors -> println("Errors: $errors") }
                )
            }) {
                Text("Submit")
            }
        }
    }
}
```

### 3. Custom Validators

Need something specific? Implement `FieldValidator` and use `@ValidatedBy`.

```kotlin
class PasswordValidator : FieldValidator<String> {
    override fun validate(value: String): String? {
        return if (value.length < 8) "Password too short" else null
    }
}

@Validatable
data class Login(
    @ValidatedBy(PasswordValidator::class)
    val password: String = ""
)
```

---

## ðŸ—ï¸ How it Works

1. **Annotations:** You mark your models with `@Validatable`.
2. **KSP Processing:** During compilation, the `FormProcessor` scans these annotations.
3. **Metadata Generation:** It generates a `*Metadata` class (e.g., `UserMetadata`) that implements `FormMetadata`. This class contains a map of properties to their respective validators.
4. **State Management:** `FormState` uses this metadata to perform validation whenever `validateAll()` or `submit()` is called, updating the `FieldState` reactively.

---

## ðŸ“¦ Installation

*(Coming soon to Maven Central)*

Add the KSP plugin and dependencies to your `build.gradle.kts`:

```kotlin
plugins {
    id("com.google.devtools.ksp") version "x.x.x"
}

dependencies {
    implementation("me.deference:formdoc:1.0.0")
    ksp("me.deference:formdoc-processor:1.0.0")
}
```

---

## ðŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

*Built with â¤ï¸ for the Kotlin Multiplatform community.*